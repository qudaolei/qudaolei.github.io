<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="@devil-agar 2017-07-11 19:13 字数 47695 阅读 129— HTML/CSS —1、XHTML 与 HTML 之间的差异2、W3C 规范/标准指的是什么？3、为什么要清除标签的默认样式？4、元素隐藏有几种方法及各自的表现？5、什么是文档流？6、meta标签7、HTML5新增元素及表单控件8、HTML5的优点9、BFC是什么？10、浮动11、CSS选择符及优先级,可继">
<meta property="og:type" content="article">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/2017/07/15/this指向 (1)/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="@devil-agar 2017-07-11 19:13 字数 47695 阅读 129— HTML/CSS —1、XHTML 与 HTML 之间的差异2、W3C 规范/标准指的是什么？3、为什么要清除标签的默认样式？4、元素隐藏有几种方法及各自的表现？5、什么是文档流？6、meta标签7、HTML5新增元素及表单控件8、HTML5的优点9、BFC是什么？10、浮动11、CSS选择符及优先级,可继">
<meta property="og:updated_time" content="2017-07-15T02:52:47.547Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="@devil-agar 2017-07-11 19:13 字数 47695 阅读 129— HTML/CSS —1、XHTML 与 HTML 之间的差异2、W3C 规范/标准指的是什么？3、为什么要清除标签的默认样式？4、元素隐藏有几种方法及各自的表现？5、什么是文档流？6、meta标签7、HTML5新增元素及表单控件8、HTML5的优点9、BFC是什么？10、浮动11、CSS选择符及优先级,可继">
  
    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客，前端知识，自我管理，知识管理，时间管理，阅读，语音写作，思维导图。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-this指向 (1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/this指向 (1)/" class="article-date">
  <time datetime="2017-07-15T02:52:47.547Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>@devil-agar 2017-07-11 19:13 字数 47695 阅读 129<br>— HTML/CSS —<br>1、XHTML 与 HTML 之间的差异<br>2、W3C 规范/标准指的是什么？<br>3、为什么要清除标签的默认样式？<br>4、元素隐藏有几种方法及各自的表现？<br>5、什么是文档流？<br>6、meta标签<br>7、HTML5新增元素及表单控件<br>8、HTML5的优点<br>9、BFC是什么？<br>10、浮动<br>11、CSS选择符及优先级,可继承与不可继承的样式<br>12、CSS3新增伪类举例<br>13、CSS3有哪些新特性？<br>— javascript —<br>14、js的数据类型有哪些？<br>15、js数据类型转换的方法<br>16、js中有几种方法判断该数据为数组？<br>17、什么是事件流，事件委托，阻止冒泡及默认行为？<br>18、简述观察者模式（自定义事件）<br>19、js的冒泡排序和快排实现方法<br>20、js的数组去重的几种方法<br>21、深度克隆以及使用递归进行深度克隆<br>22、什么是闭包？为什么使用闭包？<br>23、什么是作用域，作用域链<br>24、改变作用域链<br>25、什么是原型，原型链<br>26、面向对象<br>27、函数模拟类与类的继承<br>28、包装对象<br>29、this指向<br>30、hasOwnProperty的使用<br>31、defineProperty的使用<br>32、promise的使用，回调地狱的解决方案<br>33、iterator 遍历器/迭代器<br>34、for…of 的使用，对象和数组的 keys，values，entries 方法<br>35、js严格模式和非严格模式有哪些区别？<br>36、es6新增了哪些内容，let与var的区别，箭头函数this，Set、Map？<br>37、call() 和 apply()有什么区别？<br>38、JS 的缓存，cookies、session、localStorage、sessionStorage<br>39、JS清除缓存的方式有哪些？<br>40、什么是应用程序缓存（Application Cache）？<br>41、SSL/TLS协议运行机制<br>42、TCP/IP协议<br>43、浏览器中输入网址后到页面展现的过程<br>44、RSA加密<br>45、JS适合使用位运算吗？<br>—Ajax和跨域—<br>46、什么是Ajax?<br>47、Ajax的工作流程<br>48、同步和异步<br>49、定时器的原理<br>50、Ajax的5种状态(readyState)<br>51、HTTP状态码<br>52、如何解决跨域？<br>53、JSONP的原理<br>—Jquery—<br>54、Jquery的实现原理<br>55、Jquery的常用方法<br>56、Jquery的 $ 与 $.fn<br>57、Jquery如何扩展插件及使用<br>58、移动端视口的处理，rem的使用<br>59、移动端不支持固定定位，如何使用绝对定位进行模拟<br>60、移动端事件<br>61、移动端兼容处理<br>62、JS 兼容性问题及处理方法<br>63、PC兼容性问题及处理方法<br>范例题<br>—华丽丽的分割线—<br>图解知识点：<br>变量：<br>运算符：<br>数组：<br>流程控制：<br>字符串：<br>函数：<br>DOM操作：<br>正则：<br>— HTML/CSS —</p>
<p>1、XHTML 与 HTML 之间的差异</p>
<p>XHTML 与 HTML 4.01 标准没有太多的不同。最主要的不同： </p>
<ul>
<li>XHTML 元素必须被正确地嵌套。错误： <b> <i> text </i></b>  ;b和i没有正确嵌套 </li>
<li>XHTML 元素必须被关闭。 错误： <p>text ;p没有</p>闭合，空标签也要闭合如<br> </li>
<li>标签名必须用小写字母。 错误： <body></body> ;正确：<body></body> </li>
<li>XHTML 文档必须拥有根元素。 所有的 XHTML 元素必须被嵌套于 <html> 根元素中。<br>2、W3C 规范/标准指的是什么？</html></li>
</ul>
<p>行为、结构、样式 三者分离<br>3、为什么要清除标签的默认样式？</p>
<p>为了保证在不同浏览器下，标签的展示效果一样。<br>4、元素隐藏有几种方法及各自的表现？</p>
<p>透明度、负定位、margin<br>display : none（不占用位置）<br>visibility : hidden（占用位置）<br>5、什么是文档流？</p>
<p>文档流是文档中可显示对象在排列时所占用的位置。将窗体自上而下分成一行行,并在每行中按从左至右的顺序排放元素,即为文档流。<br>6、meta标签</p>
<p>META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。它不会显示在页面上，但是浏览器可以识别。</p>
<p>meta标签<br>作用：常用于定义页面的说明，关键字，最后修改日期，和其他的元数据。这些元数据将服务于浏览器（如何布局或者重载页面）搜索引擎优化和其他网络服务<br>组成：meta标签共有两个属性，分别是 http-quiv 属性和 name 属性<br>7、HTML5新增元素及表单控件</p>
<p>新增标签元素：</p>
<p><article>标签定义外部的内容（结构元素）</article></p>
<p><aside>  定义页面内容之外的内容。 aside的内容与article的内容相关。（结构元素）</aside></p>
<p><section>标签定义文档中的节（section，区段）。比如章节，页眉，页脚或文档中的其他部分（结构元素）</section></p>
<p><header> 定义 section 或 page 的页眉（介绍信息）</header></p>
<p><footer> 定义 section 或 page 的页脚</footer></p>
<p><nav>    定义导航链接。<br><time>   定义一个日期/时间  （内联元素）<br><mark>   标签定义带有记号的文本。请在需要突出显示文本时使用 <m> 标签。</m></mark></time></nav></p>
<p><audio>  定义声音内容。(内嵌元素)</audio></p>
<p><video>  定义视频。(内嵌元素)</video></p>
<p><canvas> 定义图形,绘制路径，矩形，圆形，字符以及添加图像的方法</canvas></p>
<p><keygen> 标签提供一种验证用户的可靠方法。<br>新增表单控件：</p>
<p>（1）email  电子邮箱文本框，跟普通文本框没什么区别，只有输入格式是邮箱格式或者为空的时候，验证才能通过，移动端的键盘会切换为英文键盘<br>（2）tel    电话号码，没有验证，移动端的键盘会切换为数字键盘<br>（3）url    网页的URL，有验证，由字母：// 组成的内容<br>            常用协议：http：//，https：//，ftp：//，samba：//<br>（4）search 搜索引擎，一般不用，用JS单独实现，chrome下输入文字后，会出现一个关闭的X<br>（5）range  特定范围内的数值选择器，min（从哪开始）、max（最大）、step（步数），这里的value值可以写按钮初始点在哪里，当设置了固定的step后，剩余量不足step，那么step将不再移动<br>（6）number 只能包含数字的输入框<br>（7）color  颜色选择器<br>（8）datetime-local 显示完整日期，不含时区<br>（9）time   显示时间，不含时区<br>（10）date  显示日期<br>（11）week  显示周<br>（12）month 显示月<br>新增表单特性：</p>
<p>（1）placeholder    输入框提示信息，用户在文本框输入后，提示信息自动消失。<br>（2）autocomplete   是否保存用户输入的值，on：保存（默认值），off：不保存。<br>（3）autofocus      指定表单获取输入焦点。<br>（4）required       设置此属性的表单控件为必填，不能为空。<br>（5）pattern        正则验证：pattern=“\d{1,5}”限定输入框能够输入1到5位的数字。<br>（6）formaction     可以在一个form里进行多个action地址的提交。<br>在submit里定义提交地址，该属性是添加在submit按钮上的</p>
<p><input type="submit" value="百度搜索" formaction="https://www.baidu.com/s"><br>8、HTML5的优点</p>
<p>html5的特性</p>
<p>语义特性<br>HTML5赋予网页更好的意义和结构。更加丰富的标签将随着对RDFa的，微数据与微格式等方面的支持，构建对程序、对用户都更有价值的数据驱动的Web。<br>本地存储特性（Class: OFFLINE &amp; STORAGE）<br>基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，这些全得益于HTML5 APP Cache，以及本地存储功能。Indexed DB（html5本地存储最重要的技术之一）和API说明文档。</p>
<p>设备兼容特性<br>从Geolocation功能的API文档公开以来，HTML5为网页应用开发者们提供了更多功能上的优化选择，带来了更多体验功能的优势。HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。</p>
<p>连接特性<br>更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能。</p>
<p>网页多媒体特性<br>支持网页端的Audio、Video等多媒体功能， 与网站自带的APPS，摄像头，影音功能相得益彰。<br>三维、图形及特效特性（Class: 3D, Graphics &amp; Effects）<br>基于SVG、Canvas、WebGL及CSS3的3D功能，用户会惊叹于在浏览器中，所呈现的惊人视觉效果。</p>
<p>性能与集成特性<br>没有用户会永远等待你的Loading——HTML5会通过XMLHttpRequest2等技术，解决以前的跨域等问题，帮助您的Web应用和网站在多样化的环境中更快速的工作。</p>
<p>CSS3特性<br>在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式（WOFF）也提供了更高的灵活性和控制性。</p>
<p>二、html5的优势</p>
<p>摆脱对平台的依赖<br>HTML5可以让你摆脱对平台的依赖，用户打开浏览器，直接就可以访问你的应用，而不需要经过各种Store的审核。</p>
<p>实时更新<br>实时更新，通常平台的审核都需要七个工作日左右的时间，如果你发布之后发现问题怎么办?Web方式就不存在这种问题。</p>
<p>离线使用<br>用户可以离线使用，更新下载量及少，可以全部更新，也可以选择替换部分文件。</p>
<p>代码更安全安全<br>使用HTML5，代码更安全安全。众所周知Web应用有一个很大的问题就是代码安全的问题，但现在HTML5可以将Web代码全部加密，本地应用解密后再运行，大大的提供了代码的安全性。</p>
<p>跨平台<br>HTML5可以做到跨平台，多数核心代码不用重写，Javascript的代码用得好的话，在许多地方都可以用到，包括移动应用、移动网站、PC网站、各种浏览器插件，甚至可以用WebKit封装作为跨平台的应用程序。诚然，这种方式并非完全跨平台，但这样也足以减少很多工作量了，特别是后期的维护。</p>
<p>可以充分利用Native<br>HTML5可以通过浏览器作为中介充分利用Native的好处，比如说可以使用GPS、照相机、本地相册、读取本地联系人，也可以使用推送功能等，最重要的是，某些Web无法实现的功能，我们可以利用Native来实现。</p>
<p>9、BFC是什么？</p>
<p>BFC：BFC（block formatting context）<br>BFC直译为”块级格式化上下文”，它是一个独立的渲染区域，只有Block-level Box参与，它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相关。</p>
<p>简单解释：在一个独立区域，经过重新计算后独立的渲染区域，不受外界影响</p>
<p>BFC：标准浏览器<br>haslayout：IE浏览器（非标准浏览器）</p>
<p>BFC触发条件：<br>    1、float 的值【不为】 none；<br>    2、overflow 的值【不为】 visible；<br>    3、position 的值【不为】 static 或 relative 中的任何一个；<br>    4、display 的值【为】 table-cell table-caption 和 inline-block之一；<br>haslayout触发条件：<br>    5、zoom：1；</p>
<p>BFC的布局特性：<br>    内部盒子在垂直方向一个接一个放置。<br>    兄弟元素的外边距由margin决定，在同一个BFC里的垂直边距会叠加。（解决办法：创建一个新的BFC）<br>    BFC的高度包含浮动元素。（可用以消除浮动）<br>    BFC的区域不会与浮动盒子重叠。（解决图片环绕效果）<br>    BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</p>
<p>触发hasLayout的条件：<br>    position: absolute<br>    float: left|right<br>    display: inline-block<br>    width: 除 “auto” 外的任意值<br>    height: 除 “auto” 外的任意值 （例如很多人闭合浮动会用到 height: 1%  ）<br>    zoom: 除 “normal” 外的任意值<br>    writing-mode: tb-rl<br>    在 IE7 中，一些额外的属性也可以触发该属性：<br>    min-height: (任何值)<br>    max-height: (任何值除了none)<br>    min-width: (任何值)<br>    max-width: (任何值除了none)<br>    overflow: hidden|scroll|auto （ 这个属性在IE之前版本中没有触发 layout 的功能。 ）<br>    overflow-x|-y: hidden|scroll|auto （CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前IE版本中同样没有触发 layout 的功能）<br>10、浮动</p>
<p>浮动的定义：浮动最初的出现是为了实现图文环绕的效果。使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停下来。<br>浮动的特性：</p>
<p>1.块元素在一行显示；<br>2.内联元素支持宽高；<br>3.默认内容撑开宽度；<br>4.脱离文档流；<br>5.阻止margin叠加。<br>浮动的破坏性：高度塌陷，父级元素包不住浮动元素。</p>
<p>清除浮动：</p>
<p>1) 给浮动父级元素加高度。问题：扩展性不强。<br>2) 给浮动元素的父级加浮动。问题：浮动元素所有祖先都得加浮动。<br>3) inline-block清除浮动。问题：左右margin自动失效。<br>4) 空标签清除浮动。问题：1.必须要是块级元素；2.必须要在父级结束标签前（同级浮动元素最后边）；3.不符合w3c规范，行为、样式、结构三者分离；4.代码臃肿；5.在ie6下，最小高度19px；<br>5) <br>清浮动。问题：1.必须要是块级元素；2.必须要在父级结束标签前（同级浮动元素最后边）；3.不符合w3c规范，行为、样式、结构三者分离；4.代码臃肿。<br>6) after伪类：（after伪类是现在主流清浮动的方法）；1.元素内部末尾添加内容；2.after和content需要配合使用，缺一不可；3.after伪类会生成一个伪节点，并且能给伪节点添加任何css样式。<br>7) overflow：hidden;清除浮动。问题：1.元素以外的全部被隐藏掉；2.需要配合宽度或者zoom兼容 IE6，IE7。<br>11、CSS选择符及优先级,可继承与不可继承的样式</p>
<p>CSS 选择符：</p>
<p>1)  id选择器(# myid)<br>2)  类选择器(.myclassname)<br>3)  标签选择器(div, h1, p)<br>4)  相邻选择器(h1 + p)<br>5)  子选择器(ul &gt; li)<br>6)  后代选择器(li a)<br>7)  通配符选择器( * )<br>8)  属性选择器(a[rel = “external”])<br>9)  伪类选择器(a: hover, li:nth-child)<br>可继承的样式：可继承就是父节点设置了这个属性后，子节点就可以继承他的属性。</p>
<p>1)  font-size<br>2)  font-family<br>3)  color<br>4)  text-indent<br>5)  line-height<br>6)  cursor<br>不可继承的样式：</p>
<p>1)  border<br>2)  padding<br>3)  margin<br>4)  width<br>5)  height<br>6)  top,right,bottom,left<br><em>优先级算法：/</em>需要补充整理*/</p>
<p>1)  优先级就近原则，同权重情况下样式定义最近者为准;<br>2)  载入样式以最后载入的定位为准;<br>3)  !important &gt;  id &gt; class &gt; tag<br>4)  important 比 内联优先级高，但内联比 id 要高<br>5)  CSS优先级包含四个级别（标签内选择符，ID选择符，Class选择符，元素选择符）以及各级别出现的次数!</p>
<pre><code>根据这四个级别出现的次数计算得到CSS的优先级。
CSS优先级的计算规则如下：
    * 元素标签中定义的样式（Style属性）,加1,0,0,0
    * 每个ID选择符(如 #id),加0,1,0,0
    * 每个Class选择符(如 .class)、每个属性选择符(如 [attribute=])、每个伪类(如 :hover)加0,0,1,0
    * 每个元素选择符（如p）或伪元素选择符(如 :firstchild)等，加0,0,0,1
然后，将这四个数字分别累加，就得到每个CSS定义的优先级的值，再从左到右逐位比较大小，数字大的CSS样式的优先级就高。
</code></pre><p>12、CSS3新增伪类举例</p>
<p>1)  p:first-of-type  选择属于其父元素的首个 </p><p> 元素的每个 </p><p> 元素。<br>2)  p:last-of-type   选择属于其父元素的最后 </p><p> 元素的每个 </p><p> 元素。<br>3)  p:only-of-type   选择属于其父元素唯一的 </p><p> 元素的每个 </p><p> 元素。<br>4)  p:only-child     选择属于其父元素的唯一子元素的每个 </p><p> 元素。<br>5)  p:nth-child(2)   选择属于其父元素的第二个子元素的每个 </p><p> 元素。<br>6)  :enabled :disabled 控制表单控件的禁用状态。<br>7)  :checked         单选框或复选框被选中。<br>13、CSS3有哪些新特性？</p>
<p>1)  CSS3实现圆角（border-radius），阴影（box-shadow），<br>2)  对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）<br>3)  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜<br>4)  增加了更多的CSS选择器  多背景 rgba<br>5)  在CSS3中唯一引入的伪元素是 ::selection.(可以改变文字选中时的颜色)<br>6)  媒体查询，多栏布局<br>7)  border-image<br>— javascript —</p>
<p>14、js的数据类型有哪些？</p>
<p>基本数据类型包括：undefined、number、null、string、boolean、Symbol(ES6中新增，表示唯一的)<br>引用数据类型包括：对象(数组)<br>/* ES6引入了一种新的原始数据类型Symbol，表示独一无二的值<br>    对象的属性的类型：<br>        字符串  属性不是字符串类型，会调用toString转成字符串<br>        Symbol<br>    了解：</p>
<pre><code>1. 值是唯一的
2. 可以作为对象的属性.(注意调用问题，待补充)
3. Symbol不能和其他类型运算
</code></pre><p>*/<br>15、js数据类型转换的方法</p>
<p>将数据转换为数字类型：<br>    parseInt()  ：转换为整型 parseInt有两个参数，注意：第二个参数是进制。<br>    parseFloat()：转换为浮点型，parseFloat(‘’) // NaN<br>    Number()    ：转换为数值型，Number(‘123a’) // NaN</p>
<p>将数据转换为字符串类型：<br>    数据.toString() ：将数据转为字符串，不支持undefined、null。 传入参数将改变转换的进制(2–36)<br>        var a = 2;  a.toString(2) // “10”<br>    String()：将数据转为字符串，支持undefined、null。<br>    数据 + ‘’ 方式转成</p>
<p>将数据转换为布尔类型：<br>    Boolean()：将数据转为布尔型。</p>
<p>检测数据类型：typeOf<br>    检测后的值为：’string’, ‘number’, ‘undefined’, ‘boolean’, ‘object’, ‘function’</p>
<pre><code>NaN === NaN //false
null === null //true
null == undefined //true
null === undefined //false
</code></pre><p>16、js中有几种方法判断该数据为数组？</p>
<p>1、Array.isArray():使用数组提供的静态方法来判断，不兼容IE8。</p>
<p>2、调用对象原型的toString方法获取对象的类名，如：Object.prototype.toString.call([]);//[object Array]。toString为Object的原型方法，而Array，function等类型作为Object的实例，都重写了toString方法，所以不能直接用toString。</p>
<p>3、instanceof：使用instanceof判断Array的原型是否存在于要判断的数据的原型链上。跨页面不可靠。</p>
<p>4、constructor：使用constructor判断,var a={};a.constructor === Object //true。由于constructor 可能被修改，所以并不可靠。</p>
<p>5、使用数组独有的方法来进行判断。如push方法。var a=’123’； a.push //undefiend。这种方法也不可靠。<br>Object.prototype.toString.call(1)               //“[object Number]”<br>Object.prototype.toString.call(NaN)             //“[object Number]”<br>Object.prototype.toString.call(‘1’)             //“[object String]”<br>Object.prototype.toString.call(true)            //“[object Boolean]”<br>Object.prototype.toString.call([])              //“[object Array]”<br>Object.prototype.toString.call(function(){})    //“[object Function]”<br>Object.prototype.toString.call({})              //“[object Object]”<br>Object.prototype.toString.call(null)            //“[object Null]”<br>Object.prototype.toString.call(undefined)       //“[object Undefined]”<br>Object.prototype.toString.call(Symbol(‘a’))     //“[object Symbol]”<br>17、什么是事件流，事件委托，阻止冒泡及默认行为？</p>
<pre><code>事件流是描述页面接收事件的顺序。事件冒泡和事件捕获，事件冒泡即事件开始时由最具体的元素到不具体的元素。事件捕获即事件开始时由最不具体的元素到具体的元素。DOM2级事件流规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和冒泡阶段。事件委托利用了事件冒泡的原理。

阻止冒泡的方法：
    event.cancelBubble = true；
    event.stopPropagation();

两种方法都是阻止事件冒泡，不同之处在于stopPropagation属于W3C标准，适用于Firefox等浏览器，但是不支持IE浏览器。相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome, opera浏览器中已经支持。

取消浏览器默认行为：
    event.preventDefault()
</code></pre><p>if(e.stopPropagation){<br>    e.stopPropagation();<br>}else{<br>    e.cancelBubble = true;<br>}<br>18、简述观察者模式（自定义事件）</p>
<pre><code>订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在这个模式中需要三个部分组成：1. 发布者；2. 订阅者；3. 状态；
</code></pre><p><script><br>    //订阅发布的类<br>    class SalesOffices {<br>        constructor(){<br>            //存一下状态和订阅的函数<br>            this.books = {};<br>        }<br>        //订阅<br>        subscribe(statuss,handle){<br>            if(!this.books[statuss]){<br>                this.books[statuss] = [];<br>            }<br>            this.books[statuss].push(handle);<br>        }<br>        // 发布<br>        publish(statuss){<br>            // 根据状态找订阅者（函数）<br>            var listeners = this.books[statuss];<br>            if( listeners &amp;&amp; (listeners instanceof Array) ){<br>                for( var i = 0; i &lt; listeners.length; i++ ){<br>                    listeners<a href="">i</a>;<br>                }<br>            }<br>        }<br>        //退订<br>        unsubscribe(statuss,handle){<br>            var listeners = this.books[statuss];<br>            if( listeners &amp;&amp; (listeners instanceof Array) ){<br>                for( var i = 0; i &lt; listeners.length; i++ ){<br>                    if(listeners[i] === handle){<br>                        //要把第i个给删了<br>                        //删除数组中的某一项<br>                        listeners.splice(i,1);<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    var s = new SalesOffices;<br>    function xiaoming(){<br>        console.log(“通知小明”);<br>    }<br>    //订阅<br>    s.subscribe(“100M”,xiaoming)<br>    s.subscribe(“100M”,function (){<br>        console.log(“通知小李”);<br>    })<br>    s.subscribe(“200M”,function (){<br>        console.log(“通知小红”);<br>    })<br>    //小明要取消订阅<br>    s.unsubscribe(‘100M’,xiaoming)<br>    //在点击之后发布一个状态<br>    document.onclick = function (){<br>        s.publish(“100M”);<br>    }<br></script><br>19、js的冒泡排序和快排实现方法</p>
<pre><code>//由小到大进行冒泡排序
//冒泡的基本原理：依次比较相邻的两个数，将小数放在前面，大数放在后面。直到排序结束。
var arr = [1,3,5,2,4];
for(var i=0; i&lt;arr.length-1; i++){
    for(var j=0;j&lt;arr.length-1-i;j++){  //-i后可以提高效率
        if(arr[j]&gt;arr[j+1]){
            [arr[j],arr[j+1]]=[arr[j+1],arr[j]];
        }
    }
};
//函数版
function sort(arr){
    if(!Array.isArray(arr)){
        throw new Error(&apos;参数错误：应使用数组作为参数。&apos;)
    }
    let len = arr.length;
    if(len &lt;= 1){
        return arr;
    }else{
        len--;  //如果不len--，下面就要写 i&lt;len-1
    }
    for(let i=0; i&lt;len; i++){
        for(let j=0;j&lt;len-i;j++){
            if(arr[j]&gt;arr[j+1]){    //交换两个元素的位置也可实现从小到大或从大到小，
                [arr[j],arr[j+1]]=[arr[j+1],arr[j]];
            }
        }
    }
    return arr;
}
//快速排序
/*1 从一堆数字中随机选出一个基点(一般选择中间的)
  2 将剩下的所有的数字和这个基点进行比较，如果比这个基点小，
    就放到这个基点的左侧，如果比这个基点大就放到基点的右侧
  3 对排到基点左侧和右侧的数字重复上面的1 、2 两个步骤，
    直到排序完成(只剩下最后一个元素的时候)。*/
function quickSort(arr){
   if(arr.length &lt;= 1){
     return arr;
   }
   // 取到一个基点的索引值，一般取数组中间的那个
   var basePointIndex = Math.floor((arr.length - 1)/2);
   // 拿到对应的基点
   var basePoint = arr.splice(basePointIndex, 1)[0];
   // 分别用来存放左侧和右侧与基点比较后的数字
   var left = [], right = [];
   // 如果说arr的length不为0就一直循环去比较每一项
   while(arr.length){
     if(arr[0] &lt; basePoint){
       left.push(arr.shift());
     }else{
       right.push(arr.shift());
     }
   }
   return quickSort(left).concat( [basePoint], quickSort(right) );
</code></pre><p>20、js的数组去重的几种方法</p>
<pre><code>一般去重，我们会考虑到如何判断相同的对象和函数，对象是无序的，如果对象嵌套很深，使用循环递归来进行检测，显然是很消耗性能的。如何判定两个函数是相同的，又是一个麻烦事，所以，从源头杜绝在去重的数组中出现复杂的数据类型，如果是简单数据类型的数组去重我会使用es6 的set 方法。var s = new Set(arr)。这时返回一个Set 对象。可以使用for ...of 提取出想要的值，即可。
</code></pre><p>// set 方法：<br>function noRepeat(arr){<br>    let s = new Set(arr);<br>    let newArr = [];<br>    for( let i of s){<br>        newArr.push(i);<br>    }<br>    return newArr<br>}<br>// set 方法之 一行代码去重。 👍<br>var newArr = […new Set(arr)];<br>21、深度克隆以及使用递归进行深度克隆</p>
<p>function deepClone(obj){<br>    var result;<br>    var oType=checkType(obj);<br>    if(oType===”Object”){<br>        result={};<br>    }else if(oType===”Array”){<br>        result=[];<br>    }else{<br>        return obj;<br>    }<br>    for(key in obj){<br>        var copy=obj[key];<br>        if(checkType(copy)==”Object”){<br>            result[key]=deepClone(copy);//递归调用<br>        }else if(checkType(copy)==”Array”){<br>            result[key]=deepClone(copy);<br>        }else{<br>            result[key]=obj[key];<br>        }<br>    }<br>    return result;<br>}<br>//返回传递给他的任意对象的类<br>function checkType(o){<br>//  if(o===null) return “Null”;<br>//  if(o===undefined) return “Undefined”;<br>    return Object.prototype.toString.call(o).slice(8,-1);<br>}<br>//以下为测试：<br>var oPerson={<br>    oName:”rookiebob”,<br>    oAge:”18”,<br>    oAddress:{<br>        province:”beijing”<br>    },<br>    ofavorite:[<br>        “swimming”,<br>        {reading:”history book”}<br>    ],<br>    skill:function(){<br>        console.log(“bob is coding”);<br>    }<br>};<br>//深度克隆一个对象<br>var oNew=deepClone(oPerson);<br>oNew.ofavorite[1].reading=”picture”;<br>console.log(oNew.ofavorite[1].reading);//picture<br>console.log(oPerson.ofavorite[1].reading);//history book<br>oNew.oAddress.province=”shanghai”;<br>console.log(oPerson.oAddress.province);//beijing<br>console.log(oNew.oAddress.province);//shanghai<br>22、什么是闭包？为什么使用闭包？</p>
<ul>
<li>理解闭包：函数定义时的作用域链到函数执行时依然有效。</li>
<li>浅谈闭包：传统上来说，闭包是纯函数式编程语言的一个特性。</li>
<li>什么是闭包：闭包是一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。换句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明时的作用域内。</li>
<li><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>  那么使用闭包有什么好处呢？使用闭包的好处是：</p>
<pre><code>1.希望一个变量长期驻扎在内存中
2.避免全局变量的污染
3.私有成员的存在
</code></pre></li>
</ul>
<p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。闭包是js的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！<br>//闭包的常见实例<br>//实例1：模块化代码，减少全局变量的污染<br>    <script><br>        var abc = (function(){      //abc为外部匿名函数的返回值<br>                var a = 1;<br>                return function(){<br>                    a++;<br>                    alert(a);<br>                }<br>        })();<br>        abc();    //2 ；调用一次abc函数，其实是调用里面内部函数的返回值<br>        abc();    //3<br>    </script><br>//实例2：私有成员的存在<br>    <script><br>        var aaa = (function(){<br>                var a = 1;<br>                function bbb(){<br>                        a++;<br>                        alert(a);<br>                }<br>                function ccc(){<br>                        a++;<br>                        alert(a);<br>                }<br>                return {<br>                        b:bbb,             //json结构<br>                        c:ccc<br>                }<br>        })();<br>        aaa.b();     //2<br>        aaa.c()      //3<br>    </script><br>//实例3：使用匿名函数实现局部变量驻留内存中，从而实现累加<br>    <script type="text/javascript"><br>     function box(){<br>         var age = 100;<br>         return function(){          //匿名函数<br>              age++;<br>              return age;<br>         };<br>     }<br>    var b = box();<br>    alert(b());     //101<br>    alert(b());     //102<br>    alert(b());     //103<br>    alert(b);       //     function () {<br>                    //         age++;<br>                    //         return age;<br>                    //     }<br>    b = null；      //解除引用，等待垃圾回收<br>    </script><br>//实例4：在循环中直接找到对应元素的索引<br>    <script><br>        var aLi = document.getElementsByTagName(‘li’);<br>        for (var i=0;i<aLi.length;i++){
            aLi[i].onclick = (function(i){
                return function(){
                    alert(i);
                }
            })(i)
        }
        //也可以写作：
        for (var i=0;i<aLi.length;i++){
            (function(i){
                aLi[i].onclick = function(){
                    alert(i);
                }
            })(i);
        }
        //或者使用 let 完成这个需求：
        for (let i=0;i<aLi.length;i++){
            aLi[i].onclick = function(){
                alert(i);
            }
        }
    </script><br>//实例5：内存泄露问题<br>//由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素<br>function closure(){<br>    var oDiv = document.getElementById(‘oDiv’);//oDiv用完之后一直驻留在内存中<br>    oDiv.onclick = function () {<br>        alert(‘oDiv.innerHTML’);//这里用oDiv导致内存泄露<br>    };<br>}<br>closure();<br>//最后应将oDiv解除引用来避免内存泄露<br>function closure(){<br>    var oDiv = document.getElementById(‘oDiv’);<br>    var test = oDiv.innerHTML;<br>    oDiv.onclick = function () {<br>        alert(test);<br>    };<br>    oDiv = null;<br>}<br>23、什么是作用域，作用域链</p>
<pre><code>作用域：管理标识符的一套规则，用于标识符的正确解析。作用域划分了声明的量以及函数可以被访问的区域。JS中分为全局作用域和函数作用域。
在 script 标签内函数外的区域都属于全局作用域，全局作用域中的量以及函数在任何地方都可以被访问，所有window对象的属性拥有全局作用域。而函数中声明的量和函数只在该函数的内部有效，作用域是局部性的。局部作用域一般只在固定的代码片段内可访问到，在函数体内，局部量的优先级高于同名的全局量。

作用域链：一个可以按序检索的对象列表通过它可以进行变量的解析。检索的过程：从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量。如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。
</code></pre><p>//在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数：<br>function add(num1,num2) {<br>    var sum = num1 + num2;<br>    return sum;<br>}<br>//在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只例举了全部变量中的一部分）：<br>//函数add的作用域将会在执行时用到。例如执行如下代码：<br>var total = add(5,10);<br>//执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。<br>//每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。<br>// 在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。 该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量。如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。<br>24、改变作用域链</p>
<pre><code>函数每次执行时对应的运行期上下文都是独一无二的，所以多次调用同一个函数就会导致创建多个运行期上下文。当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被  with 语句和 catch 语句影响。
</code></pre><p>//with语句是对象的快捷应用方式，用来避免书写重复代码。例如：<br>function initUI(){<br>    with(document){<br>        var bd=body,<br>            links=getElementsByTagName(“a”),<br>            i=0,<br>            len=links.length;<br>        while(i &lt; len){<br>            update(links[i++]);<br>        }<br>        getElementById(“btnInit”).onclick=function(){<br>            doSomething();<br>        };<br>    }<br>}<br>这里使用with语句来避免多次书写document，看上去更高效，实际上产生了性能问题。</p>
<p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。<br>这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。</p>
<p>因此在程序中应避免使用with语句，在这个例子中，只要简单的把document存储在一个局部变量中就可以提升性能。</p>
<p>另外一个会改变作用域链的是try-catch语句中的catch语句。<br>当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。</p>
<p>在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。示例代码：<br>try{<br>    doSomething();<br>}catch(ex){<br>    alert(ex.message); //作用域链在此处改变<br>}<br>请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。<br>try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。<br>你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理，例如：<br>try{<br>    doSomething();<br>}catch(ex){<br>    handleError(ex); //委托给处理器方法<br>}<br>优化后的代码，handleError方法是catch子句中唯一执行的代码。<br>该函数接收异常对象作为参数，这样你可以更加灵活和统一的处理错误。<br>由于只执行一条语句，且没有局部变量的访问，作用域链的临时改变就不会影响代码性能了。<br>25、什么是原型，原型链</p>
<p>每创建一个函数，函数下都有一个属性，叫 prototype ( 原型 )。</p>
<p>prototype对应的值是一个对象，prototype的作用：通过某个构造函数创建出来的对象都可以共用这些属性和方法。</p>
<p>每创建一个对象，对象下都有一个属性，叫<strong>proto</strong>。用来指向创建这个对象的构造函数的原型 。</p>
<p>原型链和作用域链很类似，原型链是实例对象和原型之间组成的，就是用来实现共享属性和继承的。</p>
<p>当我们调用一个对象的属性或者方法的时：</p>
<pre><code>1. 首先会在该对象自身上查找
2. 如果自身没有找到，找该对象__proto__对应的构造函数的prototype上
3. 如果构造函数的prototype没有找到，找这个prototype的__proto__应的构造函数的prototype上。
</code></pre><p>Object.getPrototypeOf(object)           //用来获取一个对象的prototype对象<br>Object.setPrototypeOf(object,prototype) //用来设置一个对象的prototype对象<br>26、面向对象</p>
<pre><code>面向对象(Object Oriented,OO)是软件开发方法。面向对象程序设计，即oop。面向对象的语言有一个标志，即拥有类的概念，抽象实例对象的公共属性与方法，基于类可以创建任意多个实例对象，一般具有封装、继承、多态的特性，可重用性高。在ECMA5中并没有类的概念，我们使用函数来模拟类。
</code></pre><p>27、函数模拟类与类的继承</p>
<pre><code>继承是指一个对象直接使用另一对象的属性和方法。某些属性的值是在创建对象时候才能确定，把属性写在构造函数中，初始化某一个属性的值。我们期望的是，子类可以拥有父类的属性和方法，同时子类也可以单独拥有自己的属性和方法且互不影响。
</code></pre><p>//父类：(基类)<br>function Person( name,age ){<br>    this.name = name;<br>    this.age = age;<br>}<br>Person.prototype.say = function (){<br>    console.log(“hello,我的名字是”+this.name);<br>}<br>Person.prototype.run = function (){<br>    console.log(“hello,我的名字是”+this.name);<br>}<br>//子类1：<br>function Coder( name,age,money ){<br>                                     //属性可以通过这种方法解决，那方法呢？<br>Person.call(this,name,age)     //通过 call 的形式集成父类的属性     父类.call(子类的实例,参数1,参数2)<br>    this.money= money;<br>}<br>//方法是否可以利用 for…in 循环的特性来进行深拷贝呢？<br>//虽然可以解决，但是过多的拷贝是否违背了当初共享方法的意愿呢？<br>for( var attr in Person.prototype ){<br>    if( Person.prototype.hasOwnProperty(attr) ){<br>        Coder.prototype[attr] = Person.prototype[attr];<br>    }<br>}<br>//解决办法2：类式继承，使用第三方：<br>/<em>？思考： 为什么使用该方法后，在子类上添加方法不会影响到基类？<br>     答：当使用第三方继承时，因为第三方构建出的对象时不一样的但<strong>proto</strong>的指向是一样的。<br>        coder绑定的方法绑定在了对象上，而非该对象的原型上。</em>/<br>function inherit(cons,proto){<br>  function o(){}    //使用第三方函数代理<br>  o.prototype = proto;<br>  cons.prototype = new o;<br>  cons.prototype.constructor = cons;<br>}<br>inherit(Coder,Person.prototype);<br>coder.property.coding = function(){<br>    console.log(‘咩哈哈哈’)<br>}<br>28、包装对象</p>
<pre><code>当使用原始类型的值（string、number、boolean），在调用对应属性和方法的时候，内部会自动转成对应的对象。隐式创建的这个对象，就成为包装对象。

包装对象的特点：隐式创建对象后，可以调用对应的属性和方法，使用后，立马销毁，所以不能给原始类型的值添加属性和方法。
</code></pre><p>29、this指向</p>
<p>this：在 全局作用域 指向顶层对象 浏览器中是window this-&gt; window。<br>this：在 函数(即局部作用域) 中 this的值是在 函数调用 的时候确定的。</p>
<p>函数有哪些调用方式：</p>
<pre><code>1. 当函数在全局中直接调用时：this -&gt; window；严格模式指向undefined；
2. 通过事件调用函数时：this -&gt; 触发事件的元素；
3. 使用定时器调用函数时：this -&gt; window；
4. call 或 apply调用函数时：this -&gt; call 的第一个参数，call和apply是一样的，
   apply的第二个参数是数组形式，call (thisArg,参数1,参数2....)；apply (thisArg,[参数1,参数2....])；
5. new 调用函数时：this -&gt; 函数内部隐式创建的实例；
6. 作为对象属性值的函数被调用：this-&gt; 调用函数的对象；
7.匿名函数自执行( IIFE immediately-invoked-function-expression 立即执行函数表达式 )： this -&gt; window；

ES6. 箭头函数中的 this 指向箭头函数所在作用域中的this。
</code></pre><p>30、hasOwnProperty的使用</p>
<p>hasOwnProperty(prop)</p>
<p>作用 : 用来判断某个对象是否含有指定的自身属性,hasOwnProperty不会沿着原型链查找属性，只查找自身属性。可以配合 for…in 检索对象自身属性。</p>
<p>语法 : object.hasOwnProperty(prop)</p>
<p>参数 : prop：要检测的属性名称。</p>
<p>返回值 : 返回 boolean 值；true：自身属性，false：不为自身属性<br>31、defineProperty的使用</p>
<pre><code>Object.defineProperty(obj, prop, descriptor); 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。vue.js就是通过它实现双向绑定的。
</code></pre><p>Object.defineProperty(obj, prop, descriptor)<br>    参数说明：</p>
<pre><code>&gt;   obj：必需。目标对象 
&gt;   prop：必需。需定义或修改的属性的名字
&gt;   descriptor：必需。目标属性所拥有的特性
    {
        value：属性值
        writable: true | false 是否属性值能给改写，默认为false，不能改写.
        enumerable: true | false 是否可枚举  默认是false，不可枚举.
        configurable: true | false 是否可再次被描述 默认是true，可再次描述 可被删除.
        set(){}   在设置值的时候触发.第一个参数是val.
        get(){}   在取对象属性值的时候触发，属性值就是get的返回值.
    }
</code></pre><p>//示例：<br>            var obj = {};<br>            Object.defineProperty(obj,”test”,{  //给obj定义一个test属性<br>                value:”hello,miaov”,<br>                writable:true,      //表示可以改写<br>                enumerable:true     //表示可以枚举<br>            })<br>            obj.test = ‘我改写了’;<br>            for( var attr in obj ){<br>                console.log( attr );    // ‘test’<br>            }<br>            console.log( obj );<br>            //{text:”我改写了”}    如果 writable 不写默认 false 则输出{text:”hello,miaov”}<br>//示例： 存取器 setter/getter<br>            var obj = {<br>                test:1000,<br>                a:1<br>            };<br>            var val = ‘hello’;<br>            Object.defineProperty(obj,”test”,{<br>                get(){<br>                    console.log(“取值了”);<br>                    return val<br>                },<br>                set(value){<br>                    console.log(“我要设置值,值为：”+value);<br>                    val = value;<br>                }<br>            })<br>            obj.test = 10000;  //设置值<br>            console.log( obj.test );  //取值<br>//示例： vue基本实现       </p>
<p><body><br>    <input type="" name="" id="text"><br>    <div id="box"></div><br>    <script><br>        var obj = {<br>            message:”hello”<br>        }<br>        //通过改变message的值，来更新视图，把message做一个代理，追踪message的变化<br>        // —–模拟框架 start—–<br>        var val = obj.message;<br>        Object.defineProperty(obj,”message”,{<br>            set(value){<br>                val = value;<br>                updataView();<br>            },<br>            get(){<br>                return val;<br>            }<br>        })<br>        //用来更新视图<br>        function updataView(){<br>            box.innerHTML = obj.message;<br>        }<br>        updataView();<br>        // —–模拟框架 end—–<br>        text.oninput = function (){     //只关心如何改变数据<br>            obj.message = this.value;<br>        };<br>    </script><br></body><br>32、promise的使用，回调地狱的解决方案</p>
<pre><code>Promise 是异步编程的一种解决方案。Promise 是一个构造函数，它拥有一个参数即一个函数(executor)，这个函数参数拥有两个参数，分别是resolve函数与 reject函数。分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。
</code></pre><p>new Promise(<br>    /<em> executor </em>/<br>    function(resolve, reject) {…}<br>);<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p>
<p>33、iterator 遍历器/迭代器</p>
<pre><code>遍历器（ Iterator） 就是这样一种机制。 它是一种接口， 为各种不同的数据结构提供统一的访问机制。 任何数据结构只要部署 Iterator 接口， 就可以完成遍历操作（ 即依次处理该数据结构的所有成员）。
</code></pre><p>Iterator 的作用有三个：<br>    一是 为各种数据结构， 提供一个统一的、 简便的访问接口。<br>    二是 使得数据结构的成员能够按某种次序排列；<br>    三是 ES6 创造了一种新的遍历命令for…of循环， Iterator 接口主要供for…of消费。</p>
<p>Iterator 的遍历过程是这样的。<br>    （1） 创建一个指针对象， 指向当前数据结构的起始位置。 也就是说， 遍历器对象本质上， 就是一个指针对象。<br>    （2） 第一次调用指针对象的next方法， 可以将指针指向数据结构的第一个成员。<br>    （3） 第二次调用指针对象的next方法， 指针就指向数据结构的第二个成员。<br>    （4） 不断调用指针对象的next方法， 直到它指向数据结构的结束位置。</p>
<p>每一次调用next方法， 都会返回数据结构的当前成员的信息。 具体来说， 就是返回一个包含value和done两个属性的对象。 其中， value属性是当前成员的值， done属性是一个布尔值， 表示遍历是否结束。</p>
<p><script><br>    //封装一个方法，依次数组中的每一项，只有在调用这个方法的时候，才取值<br>    //自己写的遍历器接口<br>    var it = makeIterator([‘a’, ‘b’]);<br>    it.next() // { value: “a”, done: false }<br>    it.next() // { value: “b”, done: false }<br>    it.next() // { value: undefined, done: true }<br>    function makeIterator(array) {<br>        var nextIndex = 0;<br>        return {<br>            next: function() {<br>                return nextIndex &lt; array.length ? {<br>                    value: array[nextIndex++],<br>                    done: false<br>                } : {<br>                    value: undefined,<br>                    done: true<br>                };<br>            }<br>        };<br>    }<br>    //另一个例子<br>    var arr = [“a”,”b”,”c”];<br>    // 取出数组的遍历器接口<br>    var iterator = arr<a href="">Symbol.iterator</a>;  //遍历器对象<br>    console.log( iterator.next() );  //{value: “a”, done: false}<br>    console.log( iterator.next() );  //{value: “b”, done: false}<br>    console.log( iterator.next() );  //{value: “c”, done: false}<br>    console.log( iterator.next() );  //{value: “undefined”, done: true}<br>    var str = ‘miaovketang’;<br>    var strIterator = str<a href="">Symbol.iterator</a>;  //遍历器对象<br>    console.log( strIterator.next() );<br>    console.log( strIterator.next() );<br>    console.log( strIterator.next() );<br>    console.log( strIterator.next() );<br>    console.log( strIterator.next() );<br></script><br>34、for…of 的使用，对象和数组的 keys，values，entries 方法</p>
<p>for…in 不会调用遍历器接口，针对对象的。<br>for…of 会调用遍历器接口，不能用在对象上，因为对象没有遍历器接口。遍历器接口取的是有顺序的集合，对象是无序的，所以没有提供遍历器接口。(另：对象就是想用，该怎么办？方法1：创建一个有序的对象，不推荐。例1；方法2，详见例2。)<br>for (var value of arr){<br>    //value是数组的值，不是属性<br>}</p>
<p><script><br>// 例1：<br>    var obj = {<br>        1:”a”,<br>        0:”b”,<br>        length:2,<br>        [Symbol.iterator]:function (){<br>            var index = -1;<br>            var _this = this;<br>            return {<br>                next(){<br>                    index++;<br>                    return index !== _this.length ? {<br>                        value: _this[index] ,<br>                        done:false<br>                    } : {<br>                        value: undefined ,<br>                        done:true<br>                    }<br>                }<br>            }<br>        }<br>    };<br>    for( var value of obj ){<br>        console.log( value );<br>    }<br>// 例2：<br>    var obj = {<br>                a:1,<br>                b:2,<br>                c:function (){<br>                    console.log(hello);<br>                }<br>            };<br>    //console.dir( Object.entries(obj) ); [[a,1],[b,2]]<br>    //解构赋值<br>    for( var [key,value] of Object.entries(obj) ){<br>        console.log( key,value );<br>    }<br>    /<em><br>    几个相关的对象方法：<br>        拿到对象的key值：<br>            Object.keys(对象)  返回数组<br>                数组中存的是对象的属性值<br>        拿到对象的value值：<br>            Object.values(对象)  返回数组<br>                数组中存的是对象的属性对应的值<br>        拿到对象的key和value值<br>            Object.entries(对象)  返回数组<br>                数组中存的是key和value组成的数组<br>                [[key,value],[key,value]]
    </em>/<br>    /<em><br>        数组.keys() 返回的是遍历器接口<br>            调用返回的对象中的next依次取值<br>        数组.values()<br>            chrome 还未实现该方法(2017-06)，<br>        数组.entries() 返回的是遍历器接口
    </em>/<br>        var arr = [“a”,”b”,”c”];<br>        var keys = arr.keys();<br>        console.log(keys)               //Array Iterator {}<br>        console.log( keys.next() );     //Object {value: 0, done: false}<br>        console.log( keys.next() );     //Object {value: 1, done: false}<br>        console.log( keys.next() );     //Object {value: 2, done: false}<br>        for(  var attr of arr.keys() ){<br>            console.log( attr );        //依次打印：0，1，2<br>        }<br>        var iterator = arr.entries();<br>        for (let e of iterator) {<br>            console.log(e);    //依次打印[0, “a”]，[1, “b”]，[2, “c”]<br>        }<br></script><br>35、js严格模式和非严格模式有哪些区别？</p>
<p>设立”严格模式”的目的，主要有以下几个：<br>　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>　　- 消除代码运行的一些不安全之处，保证代码运行的安全；<br>　　- 提高编译器效率，增加运行速度；<br>　　- 为未来新版本的 Javascript 做好铺垫。<br>　　<br>启用严格模，在代码前使用：”use strict”;</p>
<p>· 将”use strict”放在脚本最前面，则整个脚本都将以”严格模式”运行。<br>· 针对单个函数，将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。</p>
<p>严格模式与非严格模式的一些区别：<br>    1、全局变量显式声明：在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明否则会报错。<br>    2、禁止使用 with 语句，因为with语句无法在编译时就确定。（Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。）<br>    3、创设eval作用域。（正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。）<br>    4、this关键字指向。修正this指向问题。未定义this指向的函数不再指向window而是undefined。<br>function abc(){<br>    console.log(this)<br>}<br>abc.call(undefined);    // window对象；     严格模式：undefined<br>abc.call(null);         // window对象；     严格模式：null<br>abc.call(1);            // Number包装对象；     严格模式：1<br>abc.call(‘a’);          // String包装对象；     严格模式：’a’<br>abc.call(true);         // Boolean包装对象；    严格模式：true<br>//使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。<br>    5、禁止在函数内部遍历调用栈。在fn 函数内部使用：fn.caller; 或 fn.arguments; // 报错，而不再是忽略。<br>    6、严格模式下无法删除变量。并报错而不是忽略掉。只有configurable设置为true的对象属性，才能被删除。<br>    7、正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。<br>　　“use strict”;<br>　　var o = {};<br>　　Object.defineProperty(o, “v”, { value: 1, writable: false });<br>　　o.v = 2; // 报错<br>    8、严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。<br>　　“use strict”;<br>　　var o = {<br>　　　　get v() { return 1; }<br>　　};<br>　　o.v = 2; // 报错<br>    9、严格模式下，对禁止扩展的对象添加新属性，会报错。<br>　　“use strict”;<br>　　var o = {};<br>　　Object.preventExtensions(o);<br>　　o.v = 1; // 报错<br>    10、严格模式下，删除一个不可删除的属性，会报错。<br>　　“use strict”;<br>　　delete Object.prototype; // 报错<br>    11、对象不能有重名的属性。正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。<br>    12、函数不能有重名的参数。正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误<br>    13、禁止八进制表示法。正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。<br>    14、不允许对arguments赋值（arguments是函数的参数对象，严格模式对它的使用做了限制。）<br>    16、arguments不再追踪参数的变化<br>　　function f(a) {<br>　　　　“use strict”;<br>　　　　a = 2;<br>　　　　return [a, arguments[0]];<br>　　}<br>　　//f(1); // 正常模式为[2,2]<br>　　//f(1); // 严格模式为[2,1]<br>    17、禁止使用arguments.callee。这意味着，你无法在匿名函数内部调用自身了。<br>    18、函数必须声明在顶层（将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。）<br>　　“use strict”;<br>　　if (true) {<br>　　　　function f() { } // 语法错误<br>　　}<br>　　<br>　　for (var i = 0; i &lt; 5; i++) {<br>　　　　function f2() { } // 语法错误<br>　　}<br>    19、保留字。为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。<br>36、es6新增了哪些内容，let与var的区别，箭头函数this，Set、Map？</p>
<p>1、ES6新增了 let 与 const 关键字</p>
<pre><code>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

let 与 var 的区别
  1 、 var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。
       let所声明的变量一定要在声明后使用，否则报错。
  2 、 let不允许在相同作用域内，重复声明同一个变量。
  3 、 暂时性死区。在代码块内，使用let命令声明变量之前，该变量都是不可用的。
       使用就会报错。暂时性死区的本质就是，只要一进入当前作用域，
       所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，
       才可以获取和使用该变量。
  4 、 let实际上为 JavaScript 新增了块级作用域。

 相同点：
        都是用来声明变量的。声明后未赋值。都是undefined。
</code></pre><p>2、箭头操作符。它简化了函数的书写。操作符左边为输入的参数，而右边则是进行的操作以及返回的值。<br>   箭头函数的 this 指向定义箭头函数所在作用域的 this 。</p>
<p>3、ES6中添加了对类的支持，引入了class关键字。现在提供原生的class支持后，对象的创建，继承更加直观了，并且父类方法的调用，实例化，静态方法和构造函数等概念都更加形象化。</p>
<p>4、字符串模板，使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}，且可以换行。</p>
<p>5、for of 值遍历：ES6中新引入的for of循环功能与 for in 相似，不同的是每次循环它提供的不是key而是value。两者区别：for…in循环会遍历一个object所有的可枚举属性。</p>
<p>6、在ES6标准中，JavaScript原生支持module了。这种将JS代码分割成不同功能的小块进行模块化。<br>// point.js<br>module “point” {<br>    export class Point {<br>        constructor (x, y) {<br>            public x = x;<br>            public y = y;<br>        }<br>    }<br>}<br>// myapp.js<br>//声明引用的模块<br>module point from “/point.js”;<br>//这里可以看出，尽管声明了引用的模块，还是可以通过指定需要的部分进行导入<br>import Point from “point”;<br>var origin = new Point(0, 0);<br>console.log(origin);<br>7、对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：<br>    · 可以在对象字面量里面定义原型<br>    · 定义方法可以不用function关键字<br>    · 直接调用父类方法<br>//通过对象字面量创建对象<br>var human = {<br>    breathe() {<br>        console.log(‘breathing…’);<br>    }<br>};<br>var worker = {<br>    <strong>proto</strong>: human, //设置此对象的原型为human,相当于继承human<br>    company: ‘freelancer’,<br>    work() {<br>        console.log(‘working…’);<br>    }<br>};<br>human.breathe();//输出 ‘breathing…’<br>//调用继承来的breathe方法<br>worker.breathe();//输出 ‘breathing…’<br>8、函数参数默认值。现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。<br>function sayHello(name){<br>    //传统的指定默认参数的方式<br>    var name=name||’dude’;<br>    console.log(‘Hello ‘+name);<br>}<br>//运用ES6的默认参数<br>function sayHello2(name=’dude’){<br>    console.log(<code>Hello ${name}</code>);<br>}<br>sayHello();//输出：Hello dude<br>sayHello(‘Wayou’);//输出：Hello Wayou<br>sayHello2();//输出：Hello dude<br>sayHello2(‘Wayou’);//输出：Hello Wayou<br>9、函数不定参数。不定参数是在函数中使用命名参数同时接收不定数量的未命名参数。这只是一种语法糖，在以前的JavaScript代码中我们可以通过arguments变量来达到这一目的。不定参数的格式是三个句点后跟代表所有不定参数的变量名。<br>//将所有参数相加的函数<br>function add(…x){<br>    return x.reduce((m,n)=&gt;m+n);<br>}<br>//传递任意个数的参数<br>console.log(add(1,2,3));//输出：6<br>console.log(add(1,2,3,4,5));//输出：15<br>10、函数拓展参数。拓展参数则是另一种形式的语法糖，它允许传递数组或者类数组直接做为函数的参数而不用通过apply。<br>var people=[‘Wayou’,’John’,’Sherlock’];<br>//sayHello函数本来接收三个单独的参数<br>function sayHello(people1,people2,people3){<br>    console.log(<code>Hello ${people1},${people2},${people3}</code>);<br>}<br>//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数<br>sayHello(…people);//输出：Hello Wayou,John,Sherlock<br>//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法<br>sayHello.apply(null,people);//输出：Hello Wayou,John,Sherlock<br>11、Map，Set 和 WeakMap，WeakSet</p>
<p>这些是新加的集合类型，提供了更加方便的获取属性值的方法，不用像以前一样用hasOwnProperty来检查某个属性是属于原型链上的呢还是当前对象的。同时，在进行属性值添加与获取时有专门的get，set 方法。<br>// Sets<br>var s = new Set();<br>s.add(“hello”).add(“goodbye”).add(“hello”);<br>s.size === 2;<br>s.has(“hello”) === true;<br>// Maps<br>var m = new Map();<br>m.set(“hello”, 42);<br>m.set(s, 34);<br>m.get(s) == 34;<br>//有时候我们会把对象作为一个对象的键用来存放属性值，普通集合类型比如简单对象会阻止垃圾回收器对这些作为属性键存在的对象的回收，有造成内存泄漏的危险。而WeakMap,WeakSet则更加安全些，这些作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉，具体还看下面的例子。<br>// Weak Maps<br>var wm = new WeakMap();<br>wm.set(s, { extra: 42 });<br>wm.size === undefined<br>// Weak Sets<br>var ws = new WeakSet();<br>ws.add({ data: 42 });//因为添加到ws的这个临时对象没有其他变量引用它，所以ws不会保存它的值，也就是说这次添加其实没有意思<br>12、Proxies：Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。<br>//定义被侦听的目标对象<br>var engineer = { name: ‘Joe Sixpack’, salary: 50 };<br>//定义处理程序<br>var interceptor = {<br>  set: function (receiver, property, value) {<br>    console.log(property, ‘is changed to’, value);<br>    receiver[property] = value;<br>  }<br>};<br>//创建代理以进行侦听<br>engineer = Proxy(engineer, interceptor);<br>//做一些改动来触发代理<br>engineer.salary = 60;//控制台输出：salary is changed to 60<br>//上面代码我已加了注释，这里进一步解释。对于处理程序，是在被侦听的对象身上发生了相应事件之后，处理程序里面的方法就会被调用，上面例子中我们设置了set的处理函数，表明，如果我们侦听的对象的属性被更改，也就是被set了，那这个处理程序就会被调用，同时通过参数能够得知是哪个属性被更改，更改为了什么值。<br>13、Symbols，新的数据类型，表示唯一的。</p>
<pre><code>我们知道对象其实是键值对的集合，而键通常来说是字符串。而现在除了字符串外，我们还可以用symbol这种值来做为对象的键。Symbol是一种基本类型，像数字，字符串还有布尔一样，它不是一个对象。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。之后就可以用这个返回值做为对象的键了。Symbol还可以用来创建私有属性，外部无法直接访问由symbol做为键的属性值。
</code></pre><p>(function() {<br>  // 创建symbol<br>  var key = Symbol(“key”);<br>  function MyClass(privateData) {<br>    this[key] = privateData;<br>  }<br>  MyClass.prototype = {<br>    doStuff: function() {<br>      … this[key] …<br>    }<br>  };<br>})();<br>var c = new MyClass(“hello”)<br>c[“key”] === undefined//无法访问该属性，因为是私有的<br>14、Math，Number，String，Object 的新API</p>
<pre><code>对Math,Number,String还有Object等添加了许多新的API。下面代码同样来自es6features，对这些新API进行了简单展示。
</code></pre><p>Number.EPSILON<br>Number.isInteger(Infinity) // false<br>Number.isNaN(“NaN”) // false<br>Math.acosh(3) // 1.762747174039086<br>Math.hypot(3, 4) // 5<br>Math.imul(Math.pow(2, 32) - 1, Math.pow(2, 32) - 2) // 2<br>“abcde”.contains(“cd”) // true<br>“abc”.repeat(3) // “abcabcabc”<br>Array.from(document.querySelectorAll(‘<em>‘)) // Returns a real Array<br>Array.of(1, 2, 3) // Similar to new Array(…), but without special one-arg behavior<br>[0, 0, 0].fill(7, 1) // [0,7,7]<br>[1,2,3].findIndex(x =&gt; x == 2) // 1<br>[“a”, “b”, “c”].entries() // iterator [0, “a”], [1,”b”], [2,”c”]<br>[“a”, “b”, “c”].keys() // iterator 0, 1, 2<br>[“a”, “b”, “c”].values() // iterator “a”, “b”, “c”<br>//iterator 表示迭代器<br>Object.assign(Point, { origin: new Point(0,0) });<br>15、Promises 是处理异步操作的一种模式，之前在很多三方库中有实现，比如jQuery的deferred 对象。当你发起一个异步请求，并绑定了.when(), .done()等事件处理程序时，其实就是在应用promise模式。<br>//创建promise<br>var promise = new Promise(function(resolve, reject) {<br>    // 进行一些异步或耗时操作<br>    if ( /</em>如果成功 */ ) {<br>        resolve(“Stuff worked!”);<br>    } else {<br>        reject(Error(“It broke”));<br>    }<br>});<br>//绑定处理程序<br>promise.then(function(result) {<br>    //promise成功的话会执行这里<br>    console.log(result); // “Stuff worked!”<br>}, function(err) {<br>    //promise失败会执行这里<br>    console.log(err); // Error: “It broke”<br>});<br>37、call() 和 apply()有什么区别？</p>
<p>两个方法都是来调用函数并改变函数this指向的方法，不同的是传入参数不同。call和apply的第一个参数传入函数运行时指定的this值，区别在于后面的参数，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。要注意的是，在非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象。<br>38、JS 的缓存，cookies、session、localStorage、sessionStorage</p>
<p>cookies: Cookie 用于存储 web 页面的用户信息。在我们进行页面cookie操作的时候，应该尽量保证cookie的数量以及相应的大小。cookie个数最好 &lt; 20~30个；cookie大小最好 &lt; 4K<br>    <script><br>        //设置cookie<br>        function setCookie(cname, cvalue, exdays) {<br>            var d = new Date();<br>            d.setTime(d.getTime() + (exdays<em>24</em>60<em>60</em>1000));<br>            var expires = “expires=”+d.toUTCString();<br>            document.cookie = cname + “=” + cvalue + “; “ + expires;<br>        }<br>        //获取cookie<br>        function getCookie(cname) {<br>            var name = cname + “=”;<br>            var ca = document.cookie.split(‘;’);<br>            for(var i=0; i<ca.length; i++) {  
                var c = ca[i];  
                while (c.charAt(0)==' ') c = c.substring(1);  
                if (c.indexOf(name) != -1) return c.substring(name.length, c.length);  
            }  
            return "";  
        }  
        //清除cookie    
        function clearCookie(name) {    
            setCookie(name, "", -1);    
        }    
        function checkCookie() {  
            var user = getCookie("username");  
            if (user != "") {  
                alert("Welcome again " + user);  
            } else {  
                user = prompt("Please enter your name:", "");  
                if (user != "" && user != null) {  
                    setCookie("username", user, 365);  
                }  
            }  
        }  
        checkCookie();   
    </script><br>session:JS是运行在客户端的脚本，因此一般是不能够设置Session，因为Session是运行在服务器端的。</p>
<p>LocalStorage：</p>
<pre><code>- 是对Cookie的优化
- 没有时间限制的数据存储
- 在隐私模式下不可读取
- 大小限制在500万字符左右，各个浏览器不一致
- 在所有同源窗口中都是共享的
- 本质是在读写文件，数据多的话会比较卡（firefox会一次性将数据导入内存）
- 不能被爬虫爬取，不要用它完全取代URL传参
- IE７及以下不支持外，其他标准浏览器都完全支持
</code></pre><p>/<em><br>JS下的操作方法:<br>    获取键值：localStorage.getItem(“key”)<br>    设置键值：localStorage.setItem(“key”,”value”)<br>    清除键值：localStorage.removeItem(“key”)<br>    清除所有键值：localStorage.clear()<br>    获取键值2：localStorage.keyName<br>    设置键值2：localStorage.keyName = “value”<br>JQ下的操作方法（JS方法前加”window.”）:<br>    获取键值：window.localStorage.getItem(“key”)<br>    设置键值：window.localStorage.setItem(“key”,”value”)<br>    清除键值：window.localStorage.removeItem(“key”)<br>    清除所有键值：window.localStorage.clear()<br>    获取键值2：window.localStorage.keyName<br>    设置键值2：window.localStorage.keyName = “value”
</em>/<br>SessionStorage：</p>
<pre><code>- 针对一个 session 的数据存储
- 大小限制在5M左右，各个浏览器不一致
- 仅在当前浏览器窗口关闭前有效（适合会话验证）
- 不在不同的浏览器窗口中共享，即使是同一个页面
</code></pre><p>39、JS清除缓存的方式有哪些？</p>
<p>( 1 )、meta方法</p>
<p>//不缓存</p>
<p><meta http-equiv="pragma" content="no-cache"> </p>
<p><meta http-equiv="Cache-Control" content="no-cache, must-revalidate"> </p>
<p><meta http-equiv="expires" content="0"><br>( 2 )、清理form表单的临时缓存</p>
<p><body onload="javascript:document.yourFormName.reset()"><br>( 3 )、jquery ajax清除浏览器缓存</body></p>
<p>//方法一：用ajax请求服务器最新文件，并加上请求头If-Modified-Since和Cache-Control,如下:<br>  $.ajax({<br>     url:’www.baidu.com’,<br>     dataType:’json’,<br>     data:{},<br>     beforeSend :function(xmlHttp){<br>        xmlHttp.setRequestHeader(“If-Modified-Since”,”0”);<br>        xmlHttp.setRequestHeader(“Cache-Control”,”no-cache”);<br>     },<br>     success:function(response){<br>         //操作<br>     }<br>     async:false<br>  });<br>//方法二，直接用cache:false,<br>  $.ajax({<br>     url:’www.baidu.com’,<br>     dataType:’json’,<br>     data:{},<br>     cache:false,<br>     ifModified :true ,<br>     success:function(response){<br>         //操作<br>     }<br>     async:false<br>  });<br>/<em>方法三：用随机数，随机数也是避免缓存的一种很不错的方法！<br>URL 参数后加上 “?ran=” + Math.random(); //当然这里参数 ran可以任意取了<br>方法四：用随机时间，和随机数一样。<br>在 URL 参数后加上 “?timestamp=” + new Date().getTime(); </em>/<br>//方法四，用php后端清理<br>//  在服务端加 header(“Cache-Control: no-cache, must-revalidate”);等等(如php中)<br>( 4 )、清除cookies</p>
<p>//通过封装的函数，给cookies 设置过期时间为-1.<br>( 5 )、清除localStorage</p>
<pre><code>获取键值：localStorage.getItem(“key”)
设置键值：localStorage.setItem(“key”,”value”)
清除键值：localStorage.removeItem(“key”)
清除所有键值：localStorage.clear()
获取键值2：localStorage.keyName
设置键值2：localStorage.keyName = “value”
</code></pre><p>( 6 )、清除sessionStorage</p>
<p>// sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。<br>40、什么是应用程序缓存（Application Cache）？</p>
<p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。所有主流浏览器均支持应用程序缓存，除了 Internet Explorer。</p>
<p>应用程序缓存为应用带来三个优势：<br>    离线浏览 - 用户可在应用离线时使用它们<br>    速度 - 已缓存资源加载得更快<br>    减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</p>
<p>如需启用应用程序缓存，请在文档的 <html> 标签中包含 manifest 属性。manifest 文件的建议的文件扩展名是：”.appcache”。请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</html></p>
<p>一旦应用被缓存，它就会保持缓存直到发生下列情况：<br>    用户清空浏览器缓存<br>    manifest 文件被修改（参阅下面的提示）<br>    由程序来更新应用缓存<br>41、SSL/TLS协议运行机制</p>
<p>SSL即安全套接层，TLS即安全传输层。互联网的通信安全，建立在SSL/TLS协议之上。不使用SSL/TLS的HTTP通信风险高，窃听风险、篡改风险、冒充风险。SSL/TLS协议是为了解决这三大风险而设计的。<br>SSL/TLS协议的基本过程是：<br>    (1) 客户端向服务器端索要并验证公钥。<br>    (2) 双方协商生成”对话密钥”。<br>    (3) 双方采用”对话密钥”进行加密通信。<br>前两步，又称为”握手阶段”（handshake）。”握手阶段”涉及四次通信.(1)客户端发出请求;(2)服务器回应;(3)客户端回应;(4)服务器的最后回应。<br>42、TCP/IP协议</p>
<p>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p>43、浏览器中输入网址后到页面展现的过程</p>
<p>　　1）用户输入网址<br>　　2）浏览器通过DNS获取网站的IP地址。客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。<br>　　　　DNS查找IP地址的顺序: 浏览器缓存、系统缓存、互联网服务提供商（ISP）的DNS缓存、递归搜索（从浏览器缓存开始，如果没找到就继续往下一个找。）找到后，浏览器会获得一个IP地址。<br>　　3）浏览器客户端发送http请求<br>　　　　HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。<br>　　4）传输层TCP传输报文。TCP协议通过“三次握手”等方法保证传输的安全可靠。<br>　　5）网络层IP协议查询MAC地址<br>　　　　IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。<br>　　7）数据到达数据链路层<br>　　　　在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束<br>　　8）服务器接收数据<br>　　　　 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。<br>　　9）服务器响应请求<br>　　　　服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。<br>　　10）服务器返回响应文件<br>　　　　请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。<br>　　11） 页面渲染： 解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。<br>　　　　关于页面渲染过程：<br>　　　　1）解析HTML代码，生成一棵DOM树<br>　　　　2）解析CSS文件<br>　　　　3）生成渲染树（受样式影响，包含不可见元素）<br>　　　　4）渲染树中的节点<br>　　　　DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。</p>
<p>　　　在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</p>
<p>44、RSA加密</p>
<p>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p>45、JS适合使用位运算吗？</p>
<p>位运算可以直接操作内存，拥有较高的性能，但JS属于弱语言，数值太大还会造成不可预见的错误，加上弱类型和各浏览器的实现不同，更加不可预见。所以不要试图直接去操纵内存，把一切都交给解释器去做。<br>—Ajax和跨域—</p>
<p>46、什么是Ajax?</p>
<p>什么是Ajax？<br>     AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。<br>     AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>47、Ajax的工作流程</p>
<p>使用流程简介：<br>        1、初始化 Ajax 对象     readyState为0<br>        2、准备请求地址及数据    readyState为1<br>        3、发送数据             readyState为2<br>        4、接收数据             readyState为3<br>        5、接收数据完成         readyState为4<br>注：当进行到某一步的时候，在ajax对象中有一个readyState记录进行的步骤，记录是为数字 0 1 2 3 4<br>48、同步和异步</p>
<pre><code>JS是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了解决这种问题，于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
</code></pre><p> 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）<br>    （1）所有同步任务都在主线程上执行，形成一个执行栈。<br>    （2）主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>    （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>    （4）主线程不断重复上面的第三步。<br>49、定时器的原理</p>
<pre><code>定时器即指定某些代码在多少时间之后执行。这叫做&quot;定时器&quot;（timer）功能，也就是定时执行的代码。定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。
</code></pre><p>以下主要讨论setTimeout()。<br>    setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。<br>console.log(1);<br>setTimeout(function(){console.log(2);},1000);<br>console.log(3);<br>//上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。<br>//————————————<br>//如果将setTimeout()的第二个参数设为0，<br>//就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。<br>setTimeout(function(){console.log(1);}, 0);<br>console.log(2);<br>//上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。<br>    总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。</p>
<pre><code>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。

需要注意的是，setTimeout()只是将事件插入了&quot;任务队列&quot;，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。
</code></pre><p>50、Ajax的5种状态(readyState)</p>
<p>0,未初始化，尚未调用open方法<br>1,启动，已经调用open方法，但尚未调用send方法<br>2,发送，已经调用send方法，但未接受响应<br>3,接受，已经接受到部分响应数据<br>4,完成，已经接受到全部响应数据，而且可以使用。<br>51、HTTP状态码</p>
<p>状态码    状态字符串    说明<br>200    OK    服务器成功返回了页面。<br>400    Bad Request    语法错误导致服务器不识别。<br>401    Unauthorized    请求需要用户认证。<br>404    Not found    指定的URL在服务器上找不到。<br>500    Internal Sever Error    服务器遇到了意外错误，无法完成请求。<br>503    SeviceUnavailable    由于服务器过载或维护导致无法完成请求。<br>52、如何解决跨域？</p>
<p>通常使用JSONP 以及 代理 的方式解决跨域。<br>53、JSONP的原理</p>
<p>Jsonp的原理。怎么去读取一个script里面的数据。</p>
<pre><code>动态添加一个&lt;script&gt;标签，而script标签的src属性是没有跨域的限制的。
首先在客户端注册一个callback, 然后把callback的名字传递给服务器. 服务端得到请求的数据后, 要用callback把要输出返回的内容包起来, 这样, 服务器生成的json数据就能被客户端正确接收了.
然后以js语法的方式,生成一个function, function的名字就是传递上来的参数callback方法的名字
最后将json数据直接以入参的方式, 放置到function中, 这样就生成了一段js语法的文档, 返回给客户端.
客户端浏览器, 解析script标签,. 并执行返回的js文档, 此时js文档数据作为参数, 传递到了客户端预先定义好的callback函数里.
</code></pre><p><script type="text/javascript"><br>    function jsonpCallback(result) {<br>        alert(result.msg);<br>    }<br></script></p>
<p><script type="text/javascript" src="http://1.com/jsonp?jsonp=jsonpCallback"></script><br>    其中jsonCallback是客户端注册的，获取跨域服务器上的JSON数据后，回调的函数。<a href="http://1.com/jsonp?jsonp=jsonpCallback" target="_blank" rel="external">http://1.com/jsonp?jsonp=jsonpCallback</a> 这个url是跨域服务器取JSON数据的接口，参数为回调函数的名字<br>    返回的格式为： jsonpCallback({msg:’this is json data’}) 。如此就生成了一段js语法的文档, 传回客户端就可以调用jsonpCallBack函数了.<br>所以这里也可以看到, 回调函数应当是定义在全局的。<br>—Jquery—</p>
<p>54、Jquery的实现原理</p>
<p><script><br>    /<em>把window作为参数传入，提高一些性能,<br>      在匿名函数中暴露一个函数，挂在window上</em>/<br>    (function (window,noGlobal){<br>        var jQuery = function (selector){<br>            return new jQuery.prototype.init(selector);<br>        };<br>        var init = jQuery.prototype.init = function (selector){<br>        }<br>        //构造函数<br>        jQuery.fn = jQuery.prototype = {<br>            constructor:jQuery,<br>            css:function (){<br>                console.log(“操作了样式”);<br>                return this;<br>            },<br>            attr:function (){<br>                console.log(“操作了行间属性”);<br>                return this;<br>            },<br>            data:function (){<br>                console.log(“操作了属性”);<br>                return this;<br>            }<br>        }<br>        //把jQuery的原型对象给到init的原型<br>        init.prototype = jQuery.prototype;<br>        window.jQuery = window.$ = jQuery;<br>    })(window);<br>    //通过new 调用jQuery后创造出的实例才能访问css方法<br>    // new $()<br>    $(“.box”).css().attr().data();<br></script><br>55、Jquery的常用方法</p>
<p>JQuery常用方法<br>1、获取元素<br>    $(“标签名”)、$(“#id”)、$(“.类名”)、$(“标签名,#id,.class”)<br>    $(“祖先 子孙”)、$(“父&gt;子”)、$(“前+后”)、$(“兄~弟”)指定层次关系<br>    $(“p[id]”)获取有id的p、$(“p[id^=p]”)获取有id且，id设定值最初部分都为p的元素<br>    $(“li:odd”)获取奇数序号元素，通过过滤器获取元素:even、:first、eq(index)、:not(:first)获取除第一个元素之外的其它元素<br>    $(“:input”)获取表单元素<br>    $(“input:text:disabled”)、:enabled、:checked、:selected通过过滤器获取表单元素<br>    $(“p”).eq(2)通过指定序号获取元素<br>    $(“p”).filter(“.center”)获取条件一致的元素<br>    $(“p”).slice(4,7)获取制定范围的元素<br>    $(“p”).is(“.blue”)获取class为blue的p<br>    $(“p”).next(“.yes”)获取p的下个class为yes的元素<br>    $(“p”).prev(“.yes”)获取前一个元素<br>    $(“p”).parent()获取父元素<br>    $(“p”).children()获取子元素<br>2、元素控制<br>    $(“div”).append(“</p><p>追加p标签</p>“)在元素内部追加内容<br>    $(“p”).appendTo(“#content”)在元素不同位置追加内容<br>    $(“p”).prepend()在元素前追加内容<br>    $(“p”).prependTo(“#content)将p追加到#content之前<br>    $(“p”).after()元素后追加兄弟元素<br>    $(“p”).before()元素前追加<br>    $(“span”).wrap(“<div></div>“)用指定结构元素包含元素<br>    $(“p”).wrapAll(“<div></div>“)用指定结构元素包含多个元素的集合<br>    $(“p”).wrapInner(“<b></b>“)用指定标签包含子元素<br>    $(A).replaceWith(B)用B元素替换A元素<br>    $(A).replaceAll(B)将B元素替换成A元素<br>    $(“p”).empty()删除p的子元素<br>    $(“p”).remove(“#id”)删除p中的id p元素<br>    $(“p”).clone().prependTo(“#id”)复制并插入元素p<br>3、获取与控制属性<br>    $(“p”).attr(name | properties | key,value | key,fn)获取、设置属性值<br>    $(“p”).removeAttr(“style”)删除属性值<br>    $(“p”).addClass(“class”) [注意：没有点]修改class属性值<br>    $(“p”).toggleClass(“class”,cnt++%3==0)根据条件设置class值<br>    $(“p”).html(val)设置html元素<br>    $(“p”).html()获取html元素<br>    $(“p”).text()获取文本<br>    $(“p”).text(val)设置文本<br>    $(“p”).val()获取、设置value<br>4、CSS控制<br>    $(“p”).css(“color”)获取元素的style属性值<br>    $(“p”).css(“color”,”red”)设置属性值<br>    $(“p”).css({color:”white”,backgroundColor:”green”})设置属性值<br>    var off=$(“p”).offset();off.top;获取元素显示位置<br>    $(“p”).height()获取元素高度<br>    $(“p”).width()获取元素宽度<br>5、事件控制<br>    $(document).ready(fn()) | $(fn())导入页面后执行函数<br>    $(“p”).bind(“click”,function(){}) | unbind 事件绑定函数<br>    $(“p”).hover(over(),out())鼠标放置/离开动作<br>    $(“p”).toggle(fn1(),fn2(),fn3(),···)元素被单击时函数的切换操作<br>    $(“p”).click(fn())元素单击事件<br>    $(“p”).mouseover()在元素中绑定mouseover事件<br>    $(“p”).mouseout()绑定mouseout事件<br>6、设定效果<br>    $(“p”).show([speed(um),[callback(fn())]])显示隐藏元素<br>    $(“p”).hide(speed,callback)隐藏显示元素<br>    $(“p”).toggle( | switch | speed,callback )切换元素显示/隐藏状态<br>    $(“p”).slideUp(speed,callback)渐进隐藏元素<br>    $(“p”).slideDown(speed,callback)逐渐显示元素<br>    $(“p”).slideToggle(speed,callback)交替显示元素<br>    $(“p”).fadeIn(speed,callback)控制元素的渐入效果<br>    $(“p”).fadeOut(speed,callback)控制元素的渐出效果<br>    $(“p”).animate(params,options | params,[duration],[easing],[callback])运行自定义动画<br>7、Ajax的控制<br>    $.ajax(options) | jQuery.ajax(options)通过HTTP通信读入页面<br>    $(“p”).load(url,data,callback)读入HTML文件后插入到元素中<br>    $(“p”).ajaxComplete(callback)ajax通信完成后执行的函数<br>    $(“p”).ajaxError(callback)设置ajax通信失败后执行的函数<br>    $(“p”).ajaxSuccess(callback)设置ajax通信成功后执行的函数<br>    $(“form”).serialize()系列化获取元素值<br>56、Jquery的 $ 与 $.fn<p></p>
<p>$.(方法)，是Jquery的静态方法； 静态方法不能被实例调用。<br>$.fn.(方法)， 是Jquery原型上的方法。Jquery把原型(prototype)简写为fn。实例可以调用Jquery原型上的方法。<br>57、Jquery如何扩展插件及使用</p>
<p>jQuery.extend(object) ;  jQuery.fn.extend()</p>
<p>jQuery.extend 用于扩展jQuery类本身，也就是用来在jQuery类/命名空间上增加新函数，或者叫静态方法，例如jQuery内置的 ajax方法都是用jQuery.ajax()这样调用的，有点像 “类名.方法名” 静态方法的调用方式。</p>
<p>jQuery.fn.extend()方法就是扩展jQuery对象的原型方法。比如开发一个插件，就可以使用这个方法。</p>
<p>jQuery.extend() 的调用并不会把方法扩展到对象的实例上，引用它的方法也需要通过jQuery类来实现，如jQuery.init()，而 jQuery.fn.extend()的调用把方法扩展到了对象的prototype上，所以实例化一个jQuery对象的时候，它就具有了这些方法，<br>58、移动端视口的处理，rem的使用</p>
<p>设备像素比：window.devicePixelRatio<br>使用meta标签：meta_viewport 针对移动端进行处理</p>
<p><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1"><br> <!--
 理想状态：让页面的宽度和设备宽度一致
            width 设备宽度 [pixel_value | device-width]
                    device-width 根据访问设备的尺寸进行调整
                    pixel_value  每个设备访问是，宽度都一致
            理想状态：
                在移动端上不想让用户缩放页面
                user-scalable 是否允许缩放 （no||yes）
            理想状态：
                比例1：1展示，并且不允许有比例的缩放,三个比例的值都一致，就能达到阻止缩放的效果
                initial-scale 初始比例
                minimum-scale 允许缩放的最小比例
                maximum-scale 允许缩放的最大比例
--><br><!-- 升级 ↓ --><br><!--
            为什么要获取像素比？？？答：希望像素1：1还原，因为无法修改像素比的值，可以通过缩放比例计算，来达到1：1像素还原的需求。 
            像素比 实际显示结果
              2         2
              3         3
               通过计算改变比例
              1/2=0.5   1
              1/3=0.3   1
        --></p>
<p><script><br>    var num = 1 / window.devicePixelRatio;<br>    document.write(‘<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale='+num+',minimum-scale='+num+',maximum-scale='+num+'" />‘)<br></script><br><!-- 升级 ↓ --><br><!--
    在任何设备上布局展示始终要一致： 
        px  绝对单位，弊端：无法做到根据屏幕大小进行缩放。
        em  相对单位，相对于当前容器字体大小。
                弊端：1、当容器有不同的font-size时，需要分别计算
                      2、无法做到根据屏幕大小进行缩放。
        %   相对单位，相对于当前容器或者父级容器。
                弊端：动态加载时，高度无法固定。那么导致高度百分比无法计算。
        rem 相对单位，r = root(根)    html节点 em = font-size(字体大小)
            相对于html节点的字体大小
            rem优点：只依赖与html的字体大小。
--></p>
<p><script><br>    var num = 1 / window.devicePixelRatio;<br>    document.write(‘<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale='+num+',minimum-scale='+num+',maximum-scale='+num+'" />‘)<br>    var fontNum = document.documentElement.clientWidth / 10;<br>    var html = document.getElementsByTagName(‘html’)[0];<br>    html.style.fontSize = fontNum + ‘px’;<br></script><br>59、移动端不支持固定定位，如何使用绝对定位进行模拟</p>
<p>&lt;!DOCTYPE html&gt;</p>
<p><html><br>    <head><br>        <meta charset="UTF-8"><br>        <title></title><br>        <!-- 使用 JS 获取 像素比及设置缩放比例。添加页面字体大小--><br>        <script><br>            var num = 1 / window.devicePixelRatio;<br>            document.write(‘<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale='+num+',minimum-scale='+num+',maximum-scale='+num+'" />‘)<br>            var fontNum = document.documentElement.clientWidth / 10;<br>            var html = document.getElementsByTagName(‘html’)[0];<br>            html.style.fontSize = fontNum + ‘px’;<br>        </script><br>        <!-- 移动端不支持固定定位，使用绝对定位进行模拟--><br>        <style><br>            .clearfix:after{<br>                content: “”;<br>                display: block;<br>                clear: both;<br>            }<br>            /<em>默认样式处理</em>/<br>            a{<br>                -webkit-tap-highlight-color:transparent;<br>            }<br>            input {-webkit-appearance:none;/<em>去除input默认样式</em>/}<br>            body{<br>                margin: 0;<br>            }<br>            /<em>主体部分</em>/<br>            html{<br>                width: 100%;<br>                height: 100%;<br>                overflow: hidden;<br>            }<br>            body{<br>                width: 100%;<br>                height: 100%;<br>                overflow-y: auto;<br>            }<br>            header{<br>                position: absolute;<br>                left: 0;<br>                top: 0;<br>                width: 100%;<br>                height: 1.5625rem;<br>                background-color: orangered;<br>            }<br>            div{<br>                float: left;<br>                width: 4.6875rem;<br>                height: 4.6875rem;<br>                margin: 0.15625rem;<br>                background-color: pink;<br>            }<br>            section{<br>                margin: 1.5625rem 0;<br>            }<br>            footer{<br>                position: absolute;<br>                left: 0;<br>                bottom: 0;<br>                width: 100%;<br>                height: 1.5625rem;<br>                background-color: paleturquoise;<br>            }<br>        </style><br>        <!--
            根据设计图的尺寸选择对应的机型
                在通过动态像素比处理后，html的宽度与设计图一致即可。
            默认样式处理
            -webkit-tap-highlight-color:transparent;
            input {-webkit-appearance:none;/*去除input默认样式*/}
        --><br>    </head><br>    <body><br>        <header></header><br>        <section class="clearfix"><br>            <div><br>                <a href="">文字</a><br>            </div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>            <div></div><br>        </section><br>        <footer></footer><br>    </body><br></html><br>60、移动端事件</p>
<p>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p>61、移动端兼容处理</p>
<p>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p>62、JS 兼容性问题及处理方法</p>
<p>。<br>。<br>。<br>。<br>。<br>。<br>。<br>。</p>
<p>63、PC兼容性问题及处理方法</p>
<p>浏览器    兼容问题    解决方案<br>IE6    最小高度的问题    1、给元素添加font-size:0;（不推荐）2、给元素添加overflow:hidden;<br>IE6    不支持1px的点线    使用背景图代替<br>IE6    margin失效    触发元素的haslayout<br>IE6    下margin失效    用padding代替margin<br>IE6    在ie6下元素内容可以撑开设置好的宽高    子级尽量不要超出父级宽高<br>IE6    不支持html5标签    1.使用js创建html5标签 document.createElement(“header”);2.直接在html中引入插件 html5shiv.min.js<br>IE6/7    不支持将元素的display属性设置成table相关类型    无解<br>IE6    只支持a伪类，其他元素的伪类不支持    在iea6下尽量避免使用a以外的伪类状态；给属性添加cursor:pointer;功能用js实现<br>IE6/7    不支持将块级元素转化为inline-block属性    可以使用浮动或其他方法模拟inline-block的特性；触发haslayout。zoom：1<br>IE6    行高失效    使用浮动或者其他属性来实现相似功能<br>IE6    双倍外边距    给元素添加display:inline;属性<br>IE6    浮动常犯错误：1.子元素撑开父级设置好的宽高 2.在ie6下元素浮动在一行，每一行元素都要加浮动    1.尽量避免自己超出父级的宽高；2.需要一行显示的元素，都要加浮动，并且加给同级关系的元素，能给宽度的一定要给宽。<br>IE6    文字溢出    1.给注释或者内嵌元素用div包起来；2. 给父级的宽度加宽3px；3.在浮动元素之间避免注释或者空标签<br>IE6    li下的间隙    1.给li加浮动；2. 给li添加vertical-align:top;<br>IE6    清浮动    .clear:after { content: “”;clear: both;display: block;}.clear{ zoom:1;}<br>IE6    在ie6下，浮动元素和绝对定位元素是并列关系的话，绝对定位会消失掉    给绝对定位元素单独包起来<br>IE6/7    元素有相对定位的话，父级的overflow对它不起作用    给元素的父级也添加相对定位<br>IE6    margin负值移出父级的部分会被截掉    给元素添加相对定位属性<br>IE6    不支持固定定位    使用js处理效果<br>IE6    输入类型表单控件的问题：1.在ie6/7下输入类型的表单控件，上下各有1px的间隙；2.在ie6/7下输入类型的表单控件，输入文字时背景图会跟着文字一起移动；3.在ie6下输入类型的表单控件border:none;无效    1.给控件加浮动；2.背景图加给父级；3.Border:0;或者重置元素的背景<br>IE6    label的问题    在ie6下，label必须加for属性<br>IE6    不支持png透明格式    引入处理js文件<br>IE6/7/8    不支持opacity属性    Filter:alpha(opacity=num); num的取值范围是0~100之间的整数<br>chrome    最小字体是12px    尽量避免小于12px的文字。<br>范例题</p>
<p>ES6 实现：add(1)(2)=”3” ; add(1,2)=”3”; 写一个函数实现上述假设并求出 add(1,3,5)(2,5)(3)</p>
<p>var i=9;<br>function fo(){<br>    var i=0;<br>    return function(n){<br>        //return n+i++;//原题是这样的。n和i先相加，然后i再累加<br>        //return n+++i;//扩展一下思咱：如果改造成这样的代码会是什么答案。（n先和i相加，然后n自己再累加）<br>        return n+(++i);//这样呢？（i先累加，然后n和i再相加）<br>        //首先要明确这个i是那儿定义的，当这个方法运行的时候。<br>    }<br>};<br>var f=fo();<br>var a = f(15);<br>alert(a)          //value:<strong><strong><strong><strong>__</strong></strong></strong></strong><br>var b = fo()(15); //value:<strong><strong><strong><strong>__</strong></strong></strong></strong><br>var c = fo()(20); //value:<strong><strong><strong><strong>__</strong></strong></strong></strong><br>var d = f(20);<br>alert(d);         //value:<strong><strong><strong><strong>__</strong></strong></strong></strong><br>—华丽丽的分割线—</p>
<p>图解知识点：</p>
<p>变量：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220436065.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220436065.gif</a><br>cmd-markdown-logo</p>
<p>运算符：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220441021.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220441021.gif</a><br>cmd-markdown-logo</p>
<p>数组：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220451026.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220451026.gif</a><br>cmd-markdown-logo</p>
<p>流程控制：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220457083.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220457083.gif</a><br>cmd-markdown-logo</p>
<p>字符串：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220504074.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220504074.gif</a><br>cmd-markdown-logo</p>
<p>函数：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220504074.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220504074.gif</a><br>cmd-markdown-logo</p>
<p>DOM操作：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220519096.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220519096.gif</a><br>cmd-markdown-logo</p>
<p>正则：</p>
<p><a href="http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220525010.gif" target="_blank" rel="external">http://image18-c.poco.cn/mypoco/myphoto/20170706/22/5466304420170706220525010.gif</a><br>cmd-markdown-logo</p>
<p>+</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/15/this指向 (1)/" data-id="cj54p6frm00025srb35ep21dq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/07/15/my-new-post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">my new post</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/15/this指向 (1)/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/15/my-new-post/">my new post</a>
          </li>
        
          <li>
            <a href="/2017/07/14/hehe/">hehe</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 曲道磊<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>